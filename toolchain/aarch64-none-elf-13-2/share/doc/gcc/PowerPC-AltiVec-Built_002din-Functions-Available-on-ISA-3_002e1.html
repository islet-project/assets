<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the use of the GNU compilers.

Copyright (C) 1988-2023 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Using the GNU Compiler Collection (GCC): PowerPC AltiVec Built-in Functions Available on ISA 3.1</title>

<meta name="description" content="Using the GNU Compiler Collection (GCC): PowerPC AltiVec Built-in Functions Available on ISA 3.1">
<meta name="keywords" content="Using the GNU Compiler Collection (GCC): PowerPC AltiVec Built-in Functions Available on ISA 3.1">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Indices.html#Indices" rel="index" title="Indices">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" rel="up" title="PowerPC AltiVec/VSX Built-in Functions">
<link href="PowerPC-Hardware-Transactional-Memory-Built_002din-Functions.html#PowerPC-Hardware-Transactional-Memory-Built_002din-Functions" rel="next" title="PowerPC Hardware Transactional Memory Built-in Functions">
<link href="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0.html#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0" rel="previous" title="PowerPC AltiVec Built-in Functions Available on ISA 3.0">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en_US" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1"></a>
<div class="header">
<p>
Previous: <a href="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0.html#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0" accesskey="p" rel="previous">PowerPC AltiVec Built-in Functions Available on ISA 3.0</a>, Up: <a href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" accesskey="u" rel="up">PowerPC AltiVec/VSX Built-in Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indices.html#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1-1"></a>
<h4 class="subsubsection">6.60.23.5 PowerPC AltiVec Built-in Functions Available on ISA 3.1</h4>

<p>The following additional built-in functions are also available for the
PowerPC family of processors, starting with ISA 3.1 (<samp>-mcpu=power10</samp>):
</p>

<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_cfuge (vector unsigned long long int, vector unsigned long long int);
</pre></div>
<p>Perform a vector centrifuge operation, as if implemented by the
<code>vcfuged</code> instruction.
<a name="index-vec_005fcfuge"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_cntlzm (vector unsigned long long int, vector unsigned long long int);
</pre></div>
<p>Perform a vector count leading zeros under bit mask operation, as if
implemented by the <code>vclzdm</code> instruction.
<a name="index-vec_005fcntlzm"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_cnttzm (vector unsigned long long int, vector unsigned long long int);
</pre></div>
<p>Perform a vector count trailing zeros under bit mask operation, as if
implemented by the <code>vctzdm</code> instruction.
<a name="index-vec_005fcnttzm"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector signed char
</pre><pre class="smallexample">vec_clrl (vector signed char a, unsigned int n);
</pre><pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_clrl (vector unsigned char a, unsigned int n);
</pre></div>
<p>Clear the left-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if
implemented by the <code>vclrlb</code> instruction on a big-endian target
and by the <code>vclrrb</code> instruction on a little-endian target.  A
value of <code>n</code> that is greater than 16 is treated as if it equaled 16.
<a name="index-vec_005fclrl"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector signed char
</pre><pre class="smallexample">vec_clrr (vector signed char a, unsigned int n);
</pre><pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_clrr (vector unsigned char a, unsigned int n);
</pre></div>
<p>Clear the right-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if
implemented by the <code>vclrrb</code> instruction on a big-endian target
and by the <code>vclrlb</code> instruction on a little-endian target.  A
value of <code>n</code> that is greater than 16 is treated as if it equaled 16.
<a name="index-vec_005fclrr"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_gnb (vector unsigned __int128, const unsigned char);
</pre></div>
<p>Perform a 128-bit vector gather  operation, as if implemented by the
<code>vgnb</code> instruction.  The second argument must be a literal
integer value between 2 and 7 inclusive.
<a name="index-vec_005fgnb"></a>
</p>

<p>Vector Extract
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extractl (vector unsigned char, vector unsigned char, unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extractl (vector unsigned short, vector unsigned short, unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extractl (vector unsigned int, vector unsigned int, unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extractl (vector unsigned long long, vector unsigned long long, unsigned int);
</pre></div>
<p>Extract an element from two concatenated vectors starting at the given byte index
in natural-endian order, and place it zero-extended in doubleword 1 of the result
according to natural element order.  If the byte index is out of range for the
data type, the intrinsic will be rejected.
For little-endian, this output will match the placement by the hardware
instruction, i.e., dword[0] in RTL notation.  For big-endian, an additional
instruction is needed to move it from the &quot;left&quot; doubleword to the  &quot;right&quot; one.
For little-endian, semantics matching the <code>vextdubvrx</code>,
<code>vextduhvrx</code>, <code>vextduwvrx</code> instruction will be generated, while for
big-endian, semantics matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>,
<code>vextduwvlx</code> instructions
will be generated.  Note that some fairly anomalous results can be generated if
the byte index is not aligned on an element boundary for the element being
extracted.  This is a limitation of the bi-endian vector programming model is
consistent with the limitation on <code>vec_perm</code>.
<a name="index-vec_005fextractl"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extracth (vector unsigned char, vector unsigned char, unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extracth (vector unsigned short, vector unsigned short,
</pre><pre class="smallexample">unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extracth (vector unsigned int, vector unsigned int, unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_extracth (vector unsigned long long, vector unsigned long long,
</pre><pre class="smallexample">unsigned int);
</pre></div>
<p>Extract an element from two concatenated vectors starting at the given byte
index.  The index is based on big endian order for a little endian system.
Similarly, the index is based on little endian order for a big endian system.
The extraced elements are zero-extended and put in doubleword 1
according to natural element order.  If the byte index is out of range for the
data type, the intrinsic will be rejected.  For little-endian, this output
will match the placement by the hardware instruction (vextdubvrx, vextduhvrx,
vextduwvrx, vextddvrx) i.e., dword[0] in RTL
notation.  For big-endian, an additional instruction is needed to move it
from the &quot;left&quot; doubleword to the &quot;right&quot; one.  For little-endian, semantics
matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>, <code>vextduwvlx</code>
instructions will be generated, while for big-endian, semantics matching the
<code>vextdubvrx</code>, <code>vextduhvrx</code>, <code>vextduwvrx</code> instructions will
be generated.  Note that some fairly anomalous
results can be generated if the byte index is not aligned on the
element boundary for the element being extracted.  This is a
limitation of the bi-endian vector programming model consistent with the
limitation on <code>vec_perm</code>.
<a name="index-vec_005fextracth"></a>
</p><div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_pdep (vector unsigned long long int, vector unsigned long long int);
</pre></div>
<p>Perform a vector parallel bits deposit operation, as if implemented by
the <code>vpdepd</code> instruction.
<a name="index-vec_005fpdep"></a>
</p>
<p>Vector Insert
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_insertl (unsigned char, vector unsigned char, unsigned int);
</pre><pre class="smallexample">vector unsigned short
</pre><pre class="smallexample">vec_insertl (unsigned short, vector unsigned short, unsigned int);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_insertl (unsigned int, vector unsigned int, unsigned int);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_insertl (unsigned long long, vector unsigned long long,
</pre><pre class="smallexample">unsigned int);
</pre><pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_insertl (vector unsigned char, vector unsigned char, unsigned int;
</pre><pre class="smallexample">vector unsigned short
</pre><pre class="smallexample">vec_insertl (vector unsigned short, vector unsigned short,
</pre><pre class="smallexample">unsigned int);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_insertl (vector unsigned int, vector unsigned int, unsigned int);
</pre></div>

<p>Let src be the first argument, when the first argument is a scalar, or the
rightmost element of the left doubleword of the first argument, when the first
argument is a vector.  Insert the source into the destination at the position
given by the third argument, using natural element order in the second
argument.  The rest of the second argument is unchanged.  If the byte
index is greater than 14 for halfwords, greater than 12 for words, or
greater than 8 for doublewords the result is undefined.   For little-endian,
the generated code will be semantically equivalent to <code>vins[bhwd]rx</code>
instructions.  Similarly for big-endian it will be semantically equivalent
to <code>vins[bhwd]lx</code>.  Note that some fairly anomalous results can be
generated if the byte index is not aligned on an element boundary for the
type of element being inserted.
<a name="index-vec_005finsertl"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_inserth (unsigned char, vector unsigned char, unsigned int);
</pre><pre class="smallexample">vector unsigned short
</pre><pre class="smallexample">vec_inserth (unsigned short, vector unsigned short, unsigned int);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_inserth (unsigned int, vector unsigned int, unsigned int);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_inserth (unsigned long long, vector unsigned long long,
</pre><pre class="smallexample">unsigned int);
</pre><pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_inserth (vector unsigned char, vector unsigned char, unsigned int);
</pre><pre class="smallexample">vector unsigned short
</pre><pre class="smallexample">vec_inserth (vector unsigned short, vector unsigned short,
</pre><pre class="smallexample">unsigned int);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_inserth (vector unsigned int, vector unsigned int, unsigned int);
</pre></div>

<p>Let src be the first argument, when the first argument is a scalar, or the
rightmost element of the first argument, when the first argument is a vector.
Insert src into the second argument at the position identified by the third
argument, using opposite element order in the second argument, and leaving the
rest of the second argument unchanged.  If the byte index is greater than 14
for halfwords, 12 for words, or 8 for doublewords, the intrinsic will be
rejected. Note that the underlying hardware instruction uses the same register
for the second argument and the result.
For little-endian, the code generation will be semantically equivalent to
<code>vins[bhwd]lx</code>, while for big-endian it will be semantically equivalent to
<code>vins[bhwd]rx</code>.
Note that some fairly anomalous results can be generated if the byte index is
not aligned on an element boundary for the sort of element being inserted.
<a name="index-vec_005finserth"></a>
</p>
<p>Vector Replace Element
</p><div class="smallexample">
<pre class="smallexample">vector signed int vec_replace_elt (vector signed int, signed int,
</pre><pre class="smallexample">const int);
</pre><pre class="smallexample">vector unsigned int vec_replace_elt (vector unsigned int,
</pre><pre class="smallexample">unsigned int, const int);
</pre><pre class="smallexample">vector float vec_replace_elt (vector float, float, const int);
</pre><pre class="smallexample">vector signed long long vec_replace_elt (vector signed long long,
</pre><pre class="smallexample">signed long long, const int);
</pre><pre class="smallexample">vector unsigned long long vec_replace_elt (vector unsigned long long,
</pre><pre class="smallexample">unsigned long long, const int);
</pre><pre class="smallexample">vector double rec_replace_elt (vector double, double, const int);
</pre></div>
<p>The third argument (constrained to [0,3]) identifies the natural-endian
element number of the first argument that will be replaced by the second
argument to produce the result.  The other elements of the first argument will
remain unchanged in the result.
</p>
<p>If it&rsquo;s desirable to insert a word at an unaligned position, use
vec_replace_unaligned instead.
</p>
<a name="index-vec_005freplace_005felement"></a>

<p>Vector Replace Unaligned
</p><div class="smallexample">
<pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">signed int, const int);
</pre><pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">unsigned int, const int);
</pre><pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">float, const int);
</pre><pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">signed long long, const int);
</pre><pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">unsigned long long, const int);
</pre><pre class="smallexample">vector unsigned char vec_replace_unaligned (vector unsigned char,
</pre><pre class="smallexample">double, const int);
</pre></div>

<p>The second argument replaces a portion of the first argument to produce the
result, with the rest of the first argument unchanged in the result.  The
third argument identifies the byte index (using left-to-right, or big-endian
order) where the high-order byte of the second argument will be placed, with
the remaining bytes of the second argument placed naturally &quot;to the right&quot;
of the high-order byte.
</p>
<p>The programmer is responsible for understanding the endianness issues involved
with the first argument and the result.
<a name="index-vec_005freplace_005funaligned"></a>
</p>
<p>Vector Shift Left Double Bit Immediate
</p><div class="smallexample">
<pre class="smallexample">vector signed char vec_sldb (vector signed char, vector signed char,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned char vec_sldb (vector unsigned char,
</pre><pre class="smallexample">vector unsigned char, const unsigned int);
</pre><pre class="smallexample">vector signed short vec_sldb (vector signed short, vector signed short,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned short vec_sldb (vector unsigned short,
</pre><pre class="smallexample">vector unsigned short, const unsigned int);
</pre><pre class="smallexample">vector signed int vec_sldb (vector signed int, vector signed int,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned int vec_sldb (vector unsigned int, vector unsigned int,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector signed long long vec_sldb (vector signed long long,
</pre><pre class="smallexample">vector signed long long, const unsigned int);
</pre><pre class="smallexample">vector unsigned long long vec_sldb (vector unsigned long long,
</pre><pre class="smallexample">vector unsigned long long, const unsigned int);
</pre></div>

<p>Shift the combined input vectors left by the amount specified by the low-order
three bits of the third argument, and return the leftmost remaining 128 bits.
Code using this instruction must be endian-aware.
</p>
<a name="index-vec_005fsldb"></a>

<p>Vector Shift Right Double Bit Immediate
</p>
<div class="smallexample">
<pre class="smallexample">vector signed char vec_srdb (vector signed char, vector signed char,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned char vec_srdb (vector unsigned char, vector unsigned char,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector signed short vec_srdb (vector signed short, vector signed short,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned short vec_srdb (vector unsigned short, vector unsigned short,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector signed int vec_srdb (vector signed int, vector signed int,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector unsigned int vec_srdb (vector unsigned int, vector unsigned int,
</pre><pre class="smallexample">const unsigned int);
</pre><pre class="smallexample">vector signed long long vec_srdb (vector signed long long,
</pre><pre class="smallexample">vector signed long long, const unsigned int);
</pre><pre class="smallexample">vector unsigned long long vec_srdb (vector unsigned long long,
</pre><pre class="smallexample">vector unsigned long long, const unsigned int);
</pre></div>

<p>Shift the combined input vectors right by the amount specified by the low-order
three bits of the third argument, and return the remaining 128 bits.  Code
using this built-in must be endian-aware.
</p>
<a name="index-vec_005fsrdb"></a>

<p>Vector Splat
</p>
<div class="smallexample">
<pre class="smallexample">vector signed int vec_splati (const signed int);
</pre><pre class="smallexample">vector float vec_splati (const float);
</pre></div>

<p>Splat a 32-bit immediate into a vector of words.
</p>
<a name="index-vec_005fsplati"></a>

<div class="smallexample">
<pre class="smallexample">vector double vec_splatid (const float);
</pre></div>

<p>Convert a single precision floating-point value to double-precision and splat
the result to a vector of double-precision floats.
</p>
<a name="index-vec_005fsplatid"></a>

<div class="smallexample">
<pre class="smallexample">vector signed int vec_splati_ins (vector signed int,
</pre><pre class="smallexample">const unsigned int, const signed int);
</pre><pre class="smallexample">vector unsigned int vec_splati_ins (vector unsigned int,
</pre><pre class="smallexample">const unsigned int, const unsigned int);
</pre><pre class="smallexample">vector float vec_splati_ins (vector float, const unsigned int,
</pre><pre class="smallexample">const float);
</pre></div>

<p>Argument 2 must be either 0 or 1.  Splat the value of argument 3 into the word
identified by argument 2 of each doubleword of argument 1 and return the
result.  The other words of argument 1 are unchanged.
</p>
<a name="index-vec_005fsplati_005fins"></a>

<p>Vector Blend Variable
</p>
<div class="smallexample">
<pre class="smallexample">vector signed char vec_blendv (vector signed char, vector signed char,
</pre><pre class="smallexample">vector unsigned char);
</pre><pre class="smallexample">vector unsigned char vec_blendv (vector unsigned char,
</pre><pre class="smallexample">vector unsigned char, vector unsigned char);
</pre><pre class="smallexample">vector signed short vec_blendv (vector signed short,
</pre><pre class="smallexample">vector signed short, vector unsigned short);
</pre><pre class="smallexample">vector unsigned short vec_blendv (vector unsigned short,
</pre><pre class="smallexample">vector unsigned short, vector unsigned short);
</pre><pre class="smallexample">vector signed int vec_blendv (vector signed int, vector signed int,
</pre><pre class="smallexample">vector unsigned int);
</pre><pre class="smallexample">vector unsigned int vec_blendv (vector unsigned int,
</pre><pre class="smallexample">vector unsigned int, vector unsigned int);
</pre><pre class="smallexample">vector signed long long vec_blendv (vector signed long long,
</pre><pre class="smallexample">vector signed long long, vector unsigned long long);
</pre><pre class="smallexample">vector unsigned long long vec_blendv (vector unsigned long long,
</pre><pre class="smallexample">vector unsigned long long, vector unsigned long long);
</pre><pre class="smallexample">vector float vec_blendv (vector float, vector float,
</pre><pre class="smallexample">vector unsigned int);
</pre><pre class="smallexample">vector double vec_blendv (vector double, vector double,
</pre><pre class="smallexample">vector unsigned long long);
</pre></div>

<p>Blend the first and second argument vectors according to the sign bits of the
corresponding elements of the third argument vector.  This is similar to the
<code>vsel</code> and <code>xxsel</code> instructions but for bigger elements.
</p>
<a name="index-vec_005fblendv"></a>

<p>Vector Permute Extended
</p>
<div class="smallexample">
<pre class="smallexample">vector signed char vec_permx (vector signed char, vector signed char,
</pre><pre class="smallexample">vector unsigned char, const int);
</pre><pre class="smallexample">vector unsigned char vec_permx (vector unsigned char,
</pre><pre class="smallexample">vector unsigned char, vector unsigned char, const int);
</pre><pre class="smallexample">vector signed short vec_permx (vector signed short,
</pre><pre class="smallexample">vector signed short, vector unsigned char, const int);
</pre><pre class="smallexample">vector unsigned short vec_permx (vector unsigned short,
</pre><pre class="smallexample">vector unsigned short, vector unsigned char, const int);
</pre><pre class="smallexample">vector signed int vec_permx (vector signed int, vector signed int,
</pre><pre class="smallexample">vector unsigned char, const int);
</pre><pre class="smallexample">vector unsigned int vec_permx (vector unsigned int,
</pre><pre class="smallexample">vector unsigned int, vector unsigned char, const int);
</pre><pre class="smallexample">vector signed long long vec_permx (vector signed long long,
</pre><pre class="smallexample">vector signed long long, vector unsigned char, const int);
</pre><pre class="smallexample">vector unsigned long long vec_permx (vector unsigned long long,
</pre><pre class="smallexample">vector unsigned long long, vector unsigned char, const int);
</pre><pre class="smallexample">vector float (vector float, vector float, vector unsigned char,
</pre><pre class="smallexample">const int);
</pre><pre class="smallexample">vector double (vector double, vector double, vector unsigned char,
</pre><pre class="smallexample">const int);
</pre></div>

<p>Perform a partial permute of the first two arguments, which form a 32-byte
section of an emulated vector up to 256 bytes wide, using the partial permute
control vector in the third argument.  The fourth argument (constrained to
values of 0-7) identifies which 32-byte section of the emulated vector is
contained in the first two arguments.
<a name="index-vec_005fpermx"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_pext (vector unsigned long long int, vector unsigned long long int);
</pre></div>
<p>Perform a vector parallel bit extract operation, as if implemented by
the <code>vpextd</code> instruction.
<a name="index-vec_005fpext"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char vec_stril (vector unsigned char);
</pre><pre class="smallexample">vector signed char vec_stril (vector signed char);
</pre><pre class="smallexample">vector unsigned short vec_stril (vector unsigned short);
</pre><pre class="smallexample">vector signed short vec_stril (vector signed short);
</pre></div>
<p>Isolate the left-most non-zero elements of the incoming vector argument,
replacing all elements to the right of the left-most zero element
found within the argument with zero.  The typical implementation uses
the <code>vstribl</code> or <code>vstrihl</code> instruction on big-endian targets
and uses the <code>vstribr</code> or <code>vstrihr</code> instruction on
little-endian targets.
<a name="index-vec_005fstril"></a>
</p>
<div class="smallexample">
<pre class="smallexample">int vec_stril_p (vector unsigned char);
</pre><pre class="smallexample">int vec_stril_p (vector signed char);
</pre><pre class="smallexample">int short vec_stril_p (vector unsigned short);
</pre><pre class="smallexample">int vec_stril_p (vector signed short);
</pre></div>
<p>Return a non-zero value if and only if the argument contains a zero
element.  The typical implementation uses
the <code>vstribl.</code> or <code>vstrihl.</code> instruction on big-endian targets
and uses the <code>vstribr.</code> or <code>vstrihr.</code> instruction on
little-endian targets.  Choose this built-in to check for presence of
zero element if the same argument is also passed to <code>vec_stril</code>.
<a name="index-vec_005fstril_005fp"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char vec_strir (vector unsigned char);
</pre><pre class="smallexample">vector signed char vec_strir (vector signed char);
</pre><pre class="smallexample">vector unsigned short vec_strir (vector unsigned short);
</pre><pre class="smallexample">vector signed short vec_strir (vector signed short);
</pre></div>
<p>Isolate the right-most non-zero elements of the incoming vector argument,
replacing all elements to the left of the right-most zero element
found within the argument with zero.  The typical implementation uses
the <code>vstribr</code> or <code>vstrihr</code> instruction on big-endian targets
and uses the <code>vstribl</code> or <code>vstrihl</code> instruction on
little-endian targets.
<a name="index-vec_005fstrir"></a>
</p>
<div class="smallexample">
<pre class="smallexample">int vec_strir_p (vector unsigned char);
</pre><pre class="smallexample">int vec_strir_p (vector signed char);
</pre><pre class="smallexample">int short vec_strir_p (vector unsigned short);
</pre><pre class="smallexample">int vec_strir_p (vector signed short);
</pre></div>
<p>Return a non-zero value if and only if the argument contains a zero
element.  The typical implementation uses
the <code>vstribr.</code> or <code>vstrihr.</code> instruction on big-endian targets
and uses the <code>vstribl.</code> or <code>vstrihl.</code> instruction on
little-endian targets.  Choose this built-in to check for presence of
zero element if the same argument is also passed to <code>vec_strir</code>.
<a name="index-vec_005fstrir_005fp"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char
</pre><pre class="smallexample">vec_ternarylogic (vector unsigned char, vector unsigned char,
</pre><pre class="smallexample">            vector unsigned char, const unsigned int);
</pre><pre class="smallexample">vector unsigned short
</pre><pre class="smallexample">vec_ternarylogic (vector unsigned short, vector unsigned short,
</pre><pre class="smallexample">            vector unsigned short, const unsigned int);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_ternarylogic (vector unsigned int, vector unsigned int,
</pre><pre class="smallexample">            vector unsigned int, const unsigned int);
</pre><pre class="smallexample">vector unsigned long long int
</pre><pre class="smallexample">vec_ternarylogic (vector unsigned long long int, vector unsigned long long int,
</pre><pre class="smallexample">            vector unsigned long long int, const unsigned int);
</pre><pre class="smallexample">vector unsigned __int128
</pre><pre class="smallexample">vec_ternarylogic (vector unsigned __int128, vector unsigned __int128,
</pre><pre class="smallexample">            vector unsigned __int128, const unsigned int);
</pre></div>
<p>Perform a 128-bit vector evaluate operation, as if implemented by the
<code>xxeval</code> instruction.  The fourth argument must be a literal
integer value between 0 and 255 inclusive.
<a name="index-vec_005fternarylogic"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned char vec_genpcvm (vector unsigned char, const int);
</pre><pre class="smallexample">vector unsigned short vec_genpcvm (vector unsigned short, const int);
</pre><pre class="smallexample">vector unsigned int vec_genpcvm (vector unsigned int, const int);
</pre><pre class="smallexample">vector unsigned int vec_genpcvm (vector unsigned long long int,
</pre><pre class="smallexample">                                         const int);
</pre></div>

<p>Vector Integer Multiply/Divide/Modulo
</p>
<div class="smallexample">
<pre class="smallexample">vector signed int
</pre><pre class="smallexample">vec_mulh (vector signed int a, vector signed int b);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_mulh (vector unsigned int a, vector unsigned int b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 3, do the following. The integer
value in word element <code>i</code> of a is multiplied by the integer value in word
element <code>i</code> of b. The high-order 32 bits of the 64-bit product are placed
into word element <code>i</code> of the vector returned.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed long long
</pre><pre class="smallexample">vec_mulh (vector signed long long a, vector signed long long b);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_mulh (vector unsigned long long a, vector unsigned long long b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 1, do the following. The integer
value in doubleword element <code>i</code> of a is multiplied by the integer value in
doubleword element <code>i</code> of b. The high-order 64 bits of the 128-bit product
are placed into doubleword element <code>i</code> of the vector returned.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_mul (vector unsigned long long a, vector unsigned long long b);
</pre><pre class="smallexample">vector signed long long
</pre><pre class="smallexample">vec_mul (vector signed long long a, vector signed long long b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 1, do the following. The integer
value in doubleword element <code>i</code> of a is multiplied by the integer value in
doubleword element <code>i</code> of b. The low-order 64 bits of the 128-bit product
are placed into doubleword element <code>i</code> of the vector returned.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed int
</pre><pre class="smallexample">vec_div (vector signed int a, vector signed int b);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_div (vector unsigned int a, vector unsigned int b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is divided by the integer in word element <code>i</code>
of b. The unique integer quotient is placed into the word element <code>i</code> of
the vector returned. If an attempt is made to perform any of the divisions
&lt;anything&gt; Ã· 0 then the quotient is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed long long
</pre><pre class="smallexample">vec_div (vector signed long long a, vector signed long long b);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_div (vector unsigned long long a, vector unsigned long long b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is divided by the integer in doubleword
element <code>i</code> of b. The unique integer quotient is placed into the
doubleword element <code>i</code> of the vector returned. If an attempt is made to
perform any of the divisions 0x8000_0000_0000_0000 Ã· -1 or &lt;anything&gt; Ã· 0 then
the quotient is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed int
</pre><pre class="smallexample">vec_dive (vector signed int a, vector signed int b);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_dive (vector unsigned int a, vector unsigned int b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is shifted left by 32 bits, then divided by the
integer in word element <code>i</code> of b. The unique integer quotient is placed
into the word element <code>i</code> of the vector returned. If the quotient cannot
be represented in 32 bits, or if an attempt is made to perform any of the
divisions &lt;anything&gt; Ã· 0 then the quotient is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed long long
</pre><pre class="smallexample">vec_dive (vector signed long long a, vector signed long long b);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_dive (vector unsigned long long a, vector unsigned long long b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is shifted left by 64 bits, then divided by
the integer in doubleword element <code>i</code> of b. The unique integer quotient is
placed into the doubleword element <code>i</code> of the vector returned. If the
quotient cannot be represented in 64 bits, or if an attempt is made to perform
&lt;anything&gt; Ã· 0 then the quotient is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed int
</pre><pre class="smallexample">vec_mod (vector signed int a, vector signed int b);
</pre><pre class="smallexample">vector unsigned int
</pre><pre class="smallexample">vec_mod (vector unsigned int a, vector unsigned int b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is divided by the integer in word element <code>i</code>
of b. The unique integer remainder is placed into the word element <code>i</code> of
the vector returned.  If an attempt is made to perform any of the divisions
0x8000_0000 Ã· -1 or &lt;anything&gt; Ã· 0 then the remainder is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector signed long long
</pre><pre class="smallexample">vec_mod (vector signed long long a, vector signed long long b);
</pre><pre class="smallexample">vector unsigned long long
</pre><pre class="smallexample">vec_mod (vector unsigned long long a, vector unsigned long long b);
</pre></div>

<p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is divided by the integer in doubleword
element <code>i</code> of b. The unique integer remainder is placed into the
doubleword element <code>i</code> of the vector returned. If an attempt is made to
perform &lt;anything&gt; Ã· 0 then the remainder is undefined.
</p>
<p>Generate PCV from specified Mask size, as if implemented by the
<code>xxgenpcvbm</code>, <code>xxgenpcvhm</code>, <code>xxgenpcvwm</code> instructions, where
immediate value is either 0, 1, 2 or 3.
<a name="index-vec_005fgenpcvm"></a>
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_rl (vector unsigned __int128 A,
</pre><pre class="smallexample">                                         vector unsigned __int128 B);
</pre><pre class="smallexample">vector signed __int128 vec_rl (vector signed __int128 A,
</pre><pre class="smallexample">                                       vector unsigned __int128 B);
</pre></div>

<p>Result value: Each element of R is obtained by rotating the corresponding element
of A left by the number of bits specified by the corresponding element of B.
</p>

<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_rlmi (vector unsigned __int128,
</pre><pre class="smallexample">                                           vector unsigned __int128,
                                           vector unsigned __int128);
</pre><pre class="smallexample">vector signed __int128 vec_rlmi (vector signed __int128,
</pre><pre class="smallexample">                                         vector signed __int128,
                                         vector unsigned __int128);
</pre></div>

<p>Returns the result of rotating the first input and inserting it under mask
into the second input.  The first bit in the mask, the last bit in the mask are
obtained from the two 7-bit fields bits [108:115] and bits [117:123]
respectively of the second input.  The shift is obtained from the third input
in the 7-bit field [125:131] where all bits counted from zero at the left.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_rlnm (vector unsigned __int128,
</pre><pre class="smallexample">                                           vector unsigned __int128,
                                           vector unsigned __int128);
</pre><pre class="smallexample">vector signed __int128 vec_rlnm (vector signed __int128,
</pre><pre class="smallexample">                                         vector unsigned __int128,
                                         vector unsigned __int128);
</pre></div>

<p>Returns the result of rotating the first input and ANDing it with a mask.  The
first bit in the mask and the last bit in the mask are obtained from the two
7-bit fields bits [117:123] and bits [125:131] respectively of the second
input.  The shift is obtained from the third input in the 7-bit field bits
[125:131] where all bits counted from zero at the left.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_sl(vector unsigned __int128 A, vector unsigned __int128 B);
</pre><pre class="smallexample">vector signed __int128 vec_sl(vector signed __int128 A, vector unsigned __int128 B);
</pre></div>

<p>Result value: Each element of R is obtained by shifting the corresponding element of
A left by the number of bits specified by the corresponding element of B.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_sr(vector unsigned __int128 A, vector unsigned __int128 B);
</pre><pre class="smallexample">vector signed __int128 vec_sr(vector signed __int128 A, vector unsigned __int128 B);
</pre></div>

<p>Result value: Each element of R is obtained by shifting the corresponding element of
A right by the number of bits specified by the corresponding element of B.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_sra(vector unsigned __int128 A, vector unsigned __int128 B);
</pre><pre class="smallexample">vector signed __int128 vec_sra(vector signed __int128 A, vector unsigned __int128 B);
</pre></div>

<p>Result value: Each element of R is obtained by arithmetic shifting the corresponding
element of A right by the number of bits specified by the corresponding element of B.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_mule (vector unsigned long long,
</pre><pre class="smallexample">                                           vector unsigned long long);
</pre><pre class="smallexample">vector signed __int128 vec_mule (vector signed long long,
</pre><pre class="smallexample">                                         vector signed long long);
</pre></div>

<p>Returns a vector containing a 128-bit integer result of multiplying the even
doubleword elements of the two inputs.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_mulo (vector unsigned long long,
</pre><pre class="smallexample">                                           vector unsigned long long);
</pre><pre class="smallexample">vector signed __int128 vec_mulo (vector signed long long,
</pre><pre class="smallexample">                                         vector signed long long);
</pre></div>

<p>Returns a vector containing a 128-bit integer result of multiplying the odd
doubleword elements of the two inputs.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_div (vector unsigned __int128,
</pre><pre class="smallexample">                                          vector unsigned __int128);
</pre><pre class="smallexample">vector signed __int128 vec_div (vector signed __int128,
</pre><pre class="smallexample">                                        vector signed __int128);
</pre></div>

<p>Returns the result of dividing the first operand by the second operand. An
attempt to divide any value by zero or to divide the most negative signed
128-bit integer by negative one results in an undefined value.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_dive (vector unsigned __int128,
</pre><pre class="smallexample">                                           vector unsigned __int128);
</pre><pre class="smallexample">vector signed __int128 vec_dive (vector signed __int128,
</pre><pre class="smallexample">                                         vector signed __int128);
</pre></div>

<p>The result is produced by shifting the first input left by 128 bits and
dividing by the second.  If an attempt is made to divide by zero or the result
is larger than 128 bits, the result is undefined.
</p>
<div class="smallexample">
<pre class="smallexample">vector unsigned __int128 vec_mod (vector unsigned __int128,
</pre><pre class="smallexample">                                          vector unsigned __int128);
</pre><pre class="smallexample">vector signed __int128 vec_mod (vector signed __int128,
</pre><pre class="smallexample">                                        vector signed __int128);
</pre></div>

<p>The result is the modulo result of dividing the first input  by the second
input.
</p>
<p>The following builtins perform 128-bit vector comparisons.  The
<code>vec_all_xx</code>, <code>vec_any_xx</code>, and <code>vec_cmpxx</code>, where <code>xx</code> is
one of the operations <code>eq, ne, gt, lt, ge, le</code> perform pairwise
comparisons between the elements at the same positions within their two vector
arguments.  The <code>vec_all_xx</code>function returns a non-zero value if and only
if all pairwise comparisons are true.  The <code>vec_any_xx</code> function returns
a non-zero value if and only if at least one pairwise comparison is true.  The
<code>vec_cmpxx</code>function returns a vector of the same type as its two
arguments, within which each element consists of all ones to denote that
specified logical comparison of the corresponding elements was true.
Otherwise, the element of the returned vector contains all zeros.
</p>
<div class="smallexample">
<pre class="smallexample">vector bool __int128 vec_cmpeq (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpeq (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpne (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpne (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpgt (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpgt (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmplt (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmplt (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpge (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpge (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmple (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmple (vector unsigned __int128, vector unsigned __int128);

int vec_all_eq (vector signed __int128, vector signed __int128);
int vec_all_eq (vector unsigned __int128, vector unsigned __int128);
int vec_all_ne (vector signed __int128, vector signed __int128);
int vec_all_ne (vector unsigned __int128, vector unsigned __int128);
int vec_all_gt (vector signed __int128, vector signed __int128);
int vec_all_gt (vector unsigned __int128, vector unsigned __int128);
int vec_all_lt (vector signed __int128, vector signed __int128);
int vec_all_lt (vector unsigned __int128, vector unsigned __int128);
int vec_all_ge (vector signed __int128, vector signed __int128);
int vec_all_ge (vector unsigned __int128, vector unsigned __int128);
int vec_all_le (vector signed __int128, vector signed __int128);
int vec_all_le (vector unsigned __int128, vector unsigned __int128);

int vec_any_eq (vector signed __int128, vector signed __int128);
int vec_any_eq (vector unsigned __int128, vector unsigned __int128);
int vec_any_ne (vector signed __int128, vector signed __int128);
int vec_any_ne (vector unsigned __int128, vector unsigned __int128);
int vec_any_gt (vector signed __int128, vector signed __int128);
int vec_any_gt (vector unsigned __int128, vector unsigned __int128);
int vec_any_lt (vector signed __int128, vector signed __int128);
int vec_any_lt (vector unsigned __int128, vector unsigned __int128);
int vec_any_ge (vector signed __int128, vector signed __int128);
int vec_any_ge (vector unsigned __int128, vector unsigned __int128);
int vec_any_le (vector signed __int128, vector signed __int128);
int vec_any_le (vector unsigned __int128, vector unsigned __int128);
</pre></div>


<hr>
<div class="header">
<p>
Previous: <a href="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0.html#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0" accesskey="p" rel="previous">PowerPC AltiVec Built-in Functions Available on ISA 3.0</a>, Up: <a href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" accesskey="u" rel="up">PowerPC AltiVec/VSX Built-in Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indices.html#Indices" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
